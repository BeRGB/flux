#!/usr/bin/env node
import { mkdir, writeFile } from 'node:fs/promises';
import { dirname, extname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { load } from 'cheerio';

const products = [
	{ slug: 'ador', name: 'Ador', url: 'https://www.fluxlasers.com/products/ador/' },
	{ slug: 'beamo', name: 'Beamo', url: 'https://www.fluxlasers.com/products/beamo/' },
	{ slug: 'hexa', name: 'HEXA', url: 'https://www.fluxlasers.com/products/hexa/' },
	{ slug: 'beam-air', name: 'Beam Air', url: 'https://www.fluxlasers.com/products/beam-air/' },
];

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = resolve(__dirname, '..');
const imageDir = resolve(rootDir, 'public', 'images', 'diode');
const dataFile = resolve(rootDir, 'src', 'data', 'productMaterials.ts');

const fetchHtml = async (url) => {
	const response = await fetch(url, {
		headers: {
			'user-agent':
				'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4 Safari/605.1.15',
		},
	});

	if (!response.ok) {
		throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
	}

	return response.text();
};

const downloadImage = async (url, fileName) => {
	const response = await fetch(url, {
		headers: {
			'user-agent':
				'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4 Safari/605.1.15',
		},
	});

	if (!response.ok) {
		throw new Error(`Failed to download image ${url}: ${response.status} ${response.statusText}`);
	}

	const arrayBuffer = await response.arrayBuffer();
	const filePath = resolve(imageDir, fileName);
	await writeFile(filePath, Buffer.from(arrayBuffer));
	return `/images/diode/${fileName}`;
};

const cleanText = (value) => value.replace(/\s+/g, ' ').trim();

const slugify = (value) => value.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');

const buildFileName = (productSlug, name, imageUrl, index) => {
	const url = new URL(imageUrl);
	const ext = extname(url.pathname) || '.jpg';
	const base = slugify(name) || `material-${index + 1}`;
	return `${productSlug}-${base}${ext}`;
};

const serializeValue = (value) => JSON.stringify(value, null, '\t');

const extractMaterials = async ($, product) => {
	const container = $('#diode-list, #material-slider').first();
	if (!container.length) {
		console.warn(`⚠️  No #diode-list section found for ${product.name} (${product.url})`);
		return [];
	}

	const blocks = container.children('div').toArray();
	const results = [];

	for (const [index, block] of blocks.entries()) {
		const $block = $(block);
		const imageEl = $block.find('img').first();
		if (!imageEl.length) {
			continue;
		}

		const imageUrl = (imageEl.attr('src') ?? imageEl.attr('data-src') ?? '').trim();
		if (!imageUrl) {
			continue;
		}

		const paragraphs = $block
			.find('p')
			.map((_, el) => cleanText($(el).text()))
			.get()
			.filter(Boolean);

		if (!paragraphs.length) {
			continue;
		}

		const [name, ...details] = paragraphs;
		const fileName = buildFileName(product.slug, name, imageUrl, index);
		const imagePath = await downloadImage(imageUrl, fileName);
		results.push({ name, details, image: imagePath });
	}

	return results;
};

const main = async () => {
	await mkdir(imageDir, { recursive: true });
	const materialsMap = {};

	for (const product of products) {
		console.log(`Scraping diode list for ${product.name} (${product.url})…`);
		const html = await fetchHtml(product.url);
		const $ = load(html);
		materialsMap[product.slug] = await extractMaterials($, product);
	}

	const fileContent = `// Auto-generated by scripts/scrape-diode-list.mjs
// eslint-disable
export type ProductMaterial = {
\tname: string;
\timage: string;
\tdetails: string[];
};

export const productMaterials = ${serializeValue(materialsMap)} as const;
`;

	await writeFile(dataFile, fileContent);
	console.log(`Saved materials data to ${dataFile}`);
};

main().catch((error) => {
	console.error(error);
	process.exitCode = 1;
});
