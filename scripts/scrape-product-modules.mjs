#!/usr/bin/env node
import { mkdir, writeFile } from 'node:fs/promises';
import { dirname, extname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { load } from 'cheerio';

const products = [
	{ slug: 'ador', name: 'Ador', url: 'https://www.fluxlasers.com/products/ador/' },
];

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = resolve(__dirname, '..');
const imageDir = resolve(rootDir, 'public', 'images', 'modules');
const dataFile = resolve(rootDir, 'src', 'data', 'productModules.ts');

const fetchHtml = async (url) => {
	const response = await fetch(url, {
		headers: {
			'user-agent':
				'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4 Safari/605.1.15',
		},
	});

	if (!response.ok) {
		throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
	}

	return response.text();
};

const slugify = (value) => value.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');

const downloadImage = async (url, fileName) => {
	const response = await fetch(url, {
		headers: {
			'user-agent':
				'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4 Safari/605.1.15',
		},
	});

	if (!response.ok) {
		throw new Error(`Failed to download image ${url}: ${response.status} ${response.statusText}`);
	}

	const arrayBuffer = await response.arrayBuffer();
	const outputPath = resolve(imageDir, fileName);
	await writeFile(outputPath, Buffer.from(arrayBuffer));
	return `/images/modules/${fileName}`;
};

const cleanText = (value) => value.replace(/\s+/g, ' ').trim();

const extractModuleCards = async ($, section, product) => {
	const cards = [];
	const cardsContainer = section.find('.grid').first();

	cardsContainer.children().each((index, element) => {
		const $card = $(element);
		const $image = $card.find('img').first();
		const $title = $card.find('h3').first();
		const paragraphs = $card
			.find('p')
			.map((_, el) => cleanText($(el).text()))
			.get()
			.filter(Boolean);

		if (!$image.length || !$title.length || !paragraphs.length) {
			return;
		}

		const src =
			$image.attr('src') || $image.attr('data-src') || ($image.attr('srcset') || '').split(' ').shift() || '';
		if (!src) {
			return;
		}

		const ext = extname(new URL(src, product.url).pathname) || '.jpg';
		const fileName = `${product.slug}-${slugify($title.text())}${ext}`;

		cards.push({
			title: cleanText($title.text()),
			description: paragraphs[0] ?? '',
			materials: paragraphs[1] ?? '',
			image: {
				src,
				alt: $image.attr('alt') ?? null,
				width: $image.attr('width') ?? null,
				height: $image.attr('height') ?? null,
			},
			localImage: fileName,
			isRainbow: $title.hasClass('text-rainbow'),
		});
	});

	return cards;
};

const scrapeProductModules = async (product) => {
	const html = await fetchHtml(product.url);
	const $ = load(html);

	const moduleSection = $('section')
		.filter((_, el) => {
			const text = $(el).find('h2').first().text();
			return /Infinite possibilities/i.test(text);
		})
		.first();

	if (!moduleSection.length) {
		console.warn(`⚠️  No module section found for ${product.name} (${product.url})`);
		return null;
	}

	const cards = await extractModuleCards($, moduleSection, product);
	if (!cards.length) {
		console.warn(`⚠️  No module cards found for ${product.name} (${product.url})`);
		return null;
	}

	const headingHtml = moduleSection.find('h2').first().html()?.trim() ?? product.name;

	return {
		headingHtml,
		modules: cards,
	};
};

const serializeValue = (value) => JSON.stringify(value, (_, v) => (v === undefined ? null : v), '\t');

const main = async () => {
	await mkdir(imageDir, { recursive: true });
	const results = {};

	for (const product of products) {
		console.log(`Scraping modules for ${product.name} (${product.url})…`);
		const data = await scrapeProductModules(product);
		if (!data) continue;

		const modules = [];
		for (const module of data.modules) {
			const localSrc = await downloadImage(module.image.src, module.localImage);
			modules.push({
				title: module.title,
				description: module.description,
				materials: module.materials,
				accent: module.isRainbow ? 'rainbow' : null,
				image: {
					src: localSrc,
					alt: module.image.alt,
					width: module.image.width,
					height: module.image.height,
				},
			});
		}

		results[product.slug] = {
			headingHtml: data.headingHtml,
			modules,
		};
	}

	const fileContent = `// Auto-generated by scripts/scrape-product-modules.mjs
// eslint-disable
export type ProductModuleImage = {
\tsrc: string;
\talt: string | null;
\twidth: string | null;
\theight: string | null;
};

export type ProductModule = {
\ttitle: string;
\tdescription: string;
\tmaterials: string;
\taccent: 'rainbow' | null;
\timage: ProductModuleImage;
};

export type ProductModuleSection = {
\theadingHtml: string;
\tmodules: ProductModule[];
};

export const productModules = ${serializeValue(results)} as const;
`;

	await writeFile(dataFile, fileContent);
	console.log(`Saved product modules to ${dataFile}`);
};

main().catch((error) => {
	console.error(error);
	process.exitCode = 1;
});
