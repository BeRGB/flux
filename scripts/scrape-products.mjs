#!/usr/bin/env node
import { writeFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { load } from 'cheerio';

const products = [
	{ slug: 'ador', name: 'Ador', url: 'https://www.fluxlasers.com/products/ador/' },
	{ slug: 'beamo', name: 'Beamo', url: 'https://www.fluxlasers.com/products/beamo/' },
	{ slug: 'beambox', name: 'Beambox', url: 'https://www.fluxlasers.com/products/beambox/' },
	{ slug: 'beambox-pro', name: 'Beambox Pro', url: 'https://www.fluxlasers.com/products/beambox-pro/' },
	{ slug: 'hexa', name: 'HEXA', url: 'https://www.fluxlasers.com/products/hexa/' },
	{ slug: 'beam-air', name: 'Beam Air', url: 'https://www.fluxlasers.com/products/beam-air/' },
	{ slug: 'beam-studio', name: 'Beam Studio', url: 'https://flux3dp.com/beam-studio/' },
	{ slug: 'materials', name: 'Materials', url: 'https://www.fluxlasers.com/products/materials/' },
];

const fetchHtml = async (url) => {
	const response = await fetch(url, {
		headers: {
			'user-agent':
				'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4 Safari/605.1.15',
		},
	});

	if (!response.ok) {
		throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
	}

	return response.text();
};

const parseStyleImages = (styleText) => {
	if (!styleText) return {};
	const urls = Array.from(styleText.matchAll(/background-image:\s*url\(["']?([^"')]+)["']?\)/g)).map((m) => m[1]);
	const [mobile, desktop] = urls;
	return { mobile, desktop };
};

const extractImage = ($, el) => {
	if (!el || el.length === 0) return null;
	const $el = $(el);
	return {
		src: $el.attr('src') ?? null,
		srcset: $el.attr('srcset') ?? null,
		sizes: $el.attr('sizes') ?? null,
		alt: $el.attr('alt') ?? null,
		width: ($el.attr('width') ?? '').toString() || null,
		height: ($el.attr('height') ?? '').toString() || null,
	};
};

const cleanText = (text) => text.replace(/\s+/g, ' ').trim();

const extractSections = ($, heroSection) => {
	const sections = [];
	heroSection
		.nextAll('section')
		.each((_, section) => {
			const $section = $(section);
			const headingEl = $section.find('h2').first();
			const headingText = cleanText(headingEl.text());
			if (!headingText) {
				return;
			}

			const subheadingEl = $section.find('h3').first();
			const bodyNodes = $section.find('p, ul, ol').filter((__, el) => cleanText($(el).text()).length);

			const bodyHtml = bodyNodes
				.map((__, el) => $.html(el).trim())
				.get()
				.filter(Boolean);

			const image = extractImage($, $section.find('img').first());

			sections.push({
				heading: headingText,
				headingHtml: headingEl.html()?.trim() ?? headingText,
				subheading: cleanText(subheadingEl.text()) || null,
				subheadingHtml: subheadingEl.html()?.trim() ?? null,
				bodyHtml,
				image,
			});
		});
	return sections;
};

const scrapeProduct = async (product) => {
	const html = await fetchHtml(product.url);
	const $ = load(html);

	let heroSection = $('section.bg-hero-mobile').first();
	if (!heroSection.length) {
		heroSection = $('section')
			.filter((_, el) => {
				const $el = $(el);
				return $el.find('h1').length > 0;
			})
			.first();
	}

	if (!heroSection.length) {
		throw new Error(`Could not locate hero section for ${product.url}`);
	}

	const heroTitle = cleanText(heroSection.find('h1').first().text()) || product.name;
	const heroSubtitle = cleanText(heroSection.find('p').first().text()) || product.description || '';
	const heroCtas = heroSection
		.find('a.btn')
		.map((_, el) => {
			const $el = $(el);
			const label = cleanText($el.text());
			const variant = $el.hasClass('btn-primary') ? 'primary' : 'secondary';
			return {
				label,
				href: $el.attr('href') ?? null,
				variant,
			};
		})
		.get();

	const heroImage = extractImage($, heroSection.find('img').first());
	const background = parseStyleImages(heroSection.find('style').first().text());

	const sections = extractSections($, heroSection);

	return {
		slug: product.slug,
		name: product.name,
		storeHref: product.url,
		hero: {
			title: heroTitle,
			subtitle: heroSubtitle,
			image: heroImage,
			background,
			ctas: heroCtas,
		},
		sections,
	};
};

const serializeValue = (value) => {
	return JSON.stringify(value, (_, v) => {
		if (v === null) {
			return null;
		}
		return v;
	}, '\t');
};

const main = async () => {
	const results = [];

	for (const product of products) {
		console.log(`Scraping ${product.name} (${product.url})â€¦`);
		const data = await scrapeProduct(product);
		results.push(data);
	}

	const map = Object.fromEntries(results.map((entry) => [entry.slug, entry]));
	const fileContent = `// Auto-generated by scripts/scrape-products.mjs
// eslint-disable
export type ProductImage = {
\tsrc: string | null;
\tsrcset: string | null;
\tsizes: string | null;
\talt: string | null;
\twidth: string | null;
\theight: string | null;
};

export type ProductSection = {
\theading: string;
\theadingHtml: string;
\tsubheading: string | null;
\tsubheadingHtml: string | null;
\tbodyHtml: string[];
\timage: ProductImage | null;
};

export type ProductHero = {
\ttitle: string;
\tsubtitle: string;
\tbackground: { mobile?: string; desktop?: string };
\tctas: { label: string; href: string | null; variant: 'primary' | 'secondary' }[];
\timage: ProductImage | null;
};

export type ProductPage = {
\tslug: string;
\tname: string;
\tstoreHref: string;
\thero: ProductHero;
\tsections: ProductSection[];
};

export const productPages = ${serializeValue(map)} as const;
`;

	const targetPath = resolve('src/data/productPages.ts');
	await writeFile(targetPath, fileContent, 'utf8');
	console.log(`Wrote product data to ${targetPath}`);
};

main().catch((error) => {
	console.error(error);
	process.exitCode = 1;
});
